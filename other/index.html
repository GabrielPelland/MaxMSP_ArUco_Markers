<!--  98cm / 50,5 cm  -->
<!--  Code by GabrielPelland based on Damiano Falcioni  -->
<!DOCTYPE html>
<html>
<head>
  <title>Augmented Reality Marker Detector</title>

  <style>
    body {
      font-family: monospace;
      margin: 0;
      padding: 20px;
      background-color: #1a1a1a;
      color: white;
    }

    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    .header {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .controls {
      display: flex;
      gap: 10px;
    }

    .button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      background-color: #4CAF50;
      color: white;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    .button:hover {
      background-color: #45a049;
    }

    #video {
      display: none;
    }

    #canvas {
      width: 2048px;
      height: 1080px;
      border: 2px solid #333;
    }

    @media (max-width: 2048px) {
      #canvas {
        width: 100%;
        height: auto;
      }
    }
  </style>


  <script type="text/javascript" src="/polyfill.js"></script>
  <script type="text/javascript" src="/cv.js"></script>
  <script type="text/javascript" src="/aruco.js"></script>
  <script type="text/javascript" src="/n4m.aruco.js"></script>

  <script>
    const qrCalibration = [0, 40, 90, 80];
    const qrIds = [0, 20, 30, 40,50, 70, 80, 90];

    const POSITION_THRESHOLD = 5; // Seuil pour ignorer les petits déplacements (en pixels)
    const ROTATION_THRESHOLD = 5; // Seuil pour ignorer les petites rotations (en degrés)

    const lastSentPositions = new Map();

    let filterActive = false; // Toggle for filtering IDs
    let calibrationMode = false;
    let calibrationData = null;
    let lastCalibrationMarkers = [];

    let lastFrameTime = 0;
    const FRAME_RATE_LIMIT = 30; // Limite à 30 FPS
    const FRAME_INTERVAL = 1000 / FRAME_RATE_LIMIT;

    // Optimiser l'envoi des données
    let lastSendTime = 0;
    const SEND_INTERVAL = 50; // Limiter l'envoi à toutes les 50ms

    var video, canvas, context, imageData, detector;

    function normalizeRotation(rotation) {
      rotation = rotation % 360;
      if (rotation < 0) {
        rotation += 360;
      }
      return rotation;
    }

    function onLoad() {
      video = document.getElementById("video");
      canvas = document.getElementById("canvas");
      context = canvas.getContext("2d");

      canvas.width = 2048;
      canvas.height = 1080;

      if (navigator.mediaDevices === undefined) {
        navigator.mediaDevices = {};
      }

      if (navigator.mediaDevices.getUserMedia === undefined) {
        navigator.mediaDevices.getUserMedia = function (constraints) {
          var getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;

          if (!getUserMedia) {
            return Promise.reject(new Error('getUserMedia is not implemented in this browser'));
          }

          return new Promise(function (resolve, reject) {
            getUserMedia.call(navigator, constraints, resolve, reject);
          });
        }
      }

      navigator.mediaDevices
              .getUserMedia({ video: { width: 2048, height: 1080 } })
              .then(function (stream) {
                if ("srcObject" in video) {
                  video.srcObject = stream;
                } else {
                  video.src = window.URL.createObjectURL(stream);
                }
              })
              .catch(function (err) {
                console.log(err.name + ": " + err.message);
              });

      detector = new AR.Detector();

      requestAnimationFrame(tick);
    }

    function updateCalibrationMarkers(markers) {
      markers.forEach(newMarker => {
        const index = lastCalibrationMarkers.findIndex(m => m.id === newMarker.id);
        if (index !== -1) {
          lastCalibrationMarkers[index] = newMarker;
        } else {
          lastCalibrationMarkers.push(newMarker);
        }
      });
    }

    function startCalibration() {
      calibrationMode = true;
      lastCalibrationMarkers = [];
      document.getElementById("calibrationButton").style.display = "none";
      document.getElementById("saveCalibrationButton").style.display = "inline-block";
    }

    function saveCalibration() {
      if (lastCalibrationMarkers.length !== 4) {
        alert("Les 4 marqueurs de calibration doivent être visibles pour calibrer.");
        return;
      }

      const corners = {};
      lastCalibrationMarkers.forEach(marker => {
        switch (marker.id) {
          case 40:
            corners.topLeft = marker.corners[0];  // Store just the first corner point directly
            break;
          case 90:
            corners.bottomLeft = marker.corners[0];
            break;
          case 80:
            corners.topRight = marker.corners[0];
            break;
          case 0:
            corners.bottomRight = marker.corners[0];
            break;
        }
      });

      const width = Math.hypot(
              corners.topRight.x - corners.topLeft.x,
              corners.topRight.y - corners.topLeft.y
      );
      const height = Math.hypot(
              corners.bottomLeft.x - corners.topLeft.x,
              corners.bottomLeft.y - corners.topLeft.y
      );

      calibrationData = {
        corners: corners,  // Store corners directly
        scaleX: 980 / width, // 980mm = 98cm
        scaleY: 505 / height // 505mm = 50.5cm
      };

      calibrationMode = false;
      document.getElementById("calibrationButton").style.display = "inline-block";
      document.getElementById("saveCalibrationButton").style.display = "none";
    }

    function toggleFilter() {
      filterActive = !filterActive; // Toggle the filter
      document.getElementById("toggleButton").innerText = filterActive
              ? "Disable Filter"
              : "Enable Filter";
    }

    function tick(timestamp) {
      requestAnimationFrame(tick);

      // Limiter le taux de rafraîchissement
      const elapsed = timestamp - lastFrameTime;
      if (elapsed < FRAME_INTERVAL) return;

      lastFrameTime = timestamp - (elapsed % FRAME_INTERVAL);

      if (video.readyState !== video.HAVE_ENOUGH_DATA) return;

      // Réduire la taille du canvas pour le traitement
      const scaleFactor = 0.75; // Réduire à 75% de la taille originale
      const processWidth = canvas.width * scaleFactor;
      const processHeight = canvas.height * scaleFactor;

      // Mise à jour du context avec des paramètres optimisés
      context.imageSmoothingEnabled = false; // Désactiver le lissage pour la performance

      // Capture et traitement de l'image
      context.save();
      context.scale(1, -1);
      context.translate(0, -canvas.height);
      context.drawImage(video, 0, 0, canvas.width, canvas.height);
      context.restore();

      // Obtenir les données d'image à une résolution réduite
      imageData = context.getImageData(0, 0, processWidth, processHeight);

      // Détection des marqueurs
      let markers = detector.detect(imageData);

      // Filtrage des marqueurs
      if (calibrationMode) {
        markers = markers.filter(marker => qrCalibration.includes(marker.id));
        updateCalibrationMarkers(markers);
      } else if (filterActive) {
        markers = markers.filter(marker => qrIds.includes(marker.id));
      }

      // Mise à jour visuelle avec RequestAnimationFrame
      window.requestAnimationFrame(() => {
        drawCorners(markers);
        drawId(markers);

        if (calibrationMode) {
          drawCalibrationLines(lastCalibrationMarkers);
        } else if (calibrationData) {
          drawCalibrationOverlay();
        }
      });
    }

    function adjustCoordinates(x, y) {
      if (!calibrationData || !calibrationData.corners.topLeft) {
        return {x, y};
      }

      const {corners, scaleX, scaleY, totalHeight} = calibrationData;

      // Calcul de X comme avant
      const adjustedX = (x - corners.topLeft.x) * scaleX;

      // Inverser Y et commencer depuis le haut
      // 1. Calculer la distance depuis le haut
      // 2. Multiplier par l'échelle
      // 3. Soustraire de la hauteur totale pour inverser
      const yFromTop = y - corners.topLeft.y;
      const adjustedY = yFromTop * scaleY;

      return {
        x: adjustedX,
        y: adjustedY * -1
      };
    }

    function tick() {
      requestAnimationFrame(tick);

      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        snapshot();

        var markers = detector.detect(imageData);

        if (calibrationMode) {
          // In calibration mode, only detect calibration markers
          const calibrationMarkers = markers.filter(marker => qrCalibration.includes(marker.id));
          updateCalibrationMarkers(calibrationMarkers);
          markers = calibrationMarkers;
        } else if (filterActive) {
          // Filter markers by ID if toggle is active
          markers = markers.filter(marker => qrIds.includes(marker.id));
        }

        drawCorners(markers);
        drawId(markers);

        if (calibrationMode) {
          drawCalibrationLines(lastCalibrationMarkers);
        } else if (calibrationData) {
          drawCalibrationOverlay();
        }
      }
    }

    function snapshot() {
      context.save();
      context.scale(1, -1);
      context.translate(0, -canvas.height);

      context.drawImage(video, 0, 0, canvas.width, canvas.height);

      context.restore();

      imageData = context.getImageData(0, 0, canvas.width, canvas.height);
    }

    function drawCorners(markers) {
      var corners, corner, i, j;

      context.lineWidth = 3;

      for (i = 0; i !== markers.length; ++i) {
        corners = markers[i].corners;

        context.strokeStyle = "yellow";
        context.beginPath();

        for (j = 0; j !== corners.length; ++j) {
          corner = corners[j];
          context.moveTo(corner.x, corner.y);
          corner = corners[(j + 1) % corners.length];
          context.lineTo(corner.x, corner.y);
        }

        context.stroke();
        context.closePath();

        context.strokeStyle = "green";
        context.strokeRect(corners[0].x - 2, corners[0].y - 2, 4, 4);
      }
    }

    function calculateRotation(corners) {
      const dx = corners[1].x - corners[0].x;
      const dy = corners[1].y - corners[0].y;
      let rotation = Math.atan2(dy, dx) * (180 / Math.PI);
      return normalizeRotation(rotation);
    }

    function sendMarkerData(markerId, x, y, rotation) {
      const now = Date.now();
      if (now - lastSendTime < SEND_INTERVAL) return;

      // Vérifier si on a déjà une position précédente pour ce marqueur
      const lastPosition = lastSentPositions.get(markerId);

      if (lastPosition) {
        // Calculer les deltas
        const deltaX = x - lastPosition.x;
        const deltaY = y - lastPosition.y;
        const deltaR = rotation - lastPosition.r;

        // Calculer la distance euclidienne
        const distance = Math.sqrt(deltaX ** 2 + deltaY ** 2);

        // Si le déplacement est trop petit, on n'envoie pas
        if (distance < POSITION_THRESHOLD && Math.abs(deltaR) < ROTATION_THRESHOLD) {
          return;
        }
      }

      // Mettre à jour le temps du dernier envoi
      lastSendTime = now;

      // Sauvegarder la nouvelle position
      lastSentPositions.set(markerId, { x, y, r: rotation });

      // Ajuster les coordonnées
      let adjustedCoordinate = adjustCoordinates(x, y);

      console.log('sendData', {
        id: markerId,
        x: adjustedCoordinate.x,
        y: adjustedCoordinate.y,
        r: rotation,
      })

      fetch(`http://localhost:3000/qr/${markerId}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          id: markerId,
          x: adjustedCoordinate.x,
          y: adjustedCoordinate.y,
          r: rotation,
        })
      }).catch(err => console.error("Error sending marker data:", err));
    }

    function drawCalibrationLines(markers) {
      const corners = {};
      markers.forEach(marker => {
        switch (marker.id) {
          case 40:
            corners.topLeft = marker.corners[0];
            break;
          case 90:
            corners.bottomLeft = marker.corners[0];
            break;
          case 80:
            corners.topRight = marker.corners[0];
            break;
          case 0:
            corners.bottomRight = marker.corners[0];
            break;
        }
      });

      if (!corners.topLeft || !corners.topRight || !corners.bottomRight || !corners.bottomLeft) {
        return;
      }

      context.strokeStyle = "red";
      context.lineWidth = 2;

      context.beginPath();
      context.moveTo(corners.topLeft.x, corners.topLeft.y);
      context.lineTo(corners.topRight.x, corners.topRight.y);
      context.lineTo(corners.bottomRight.x, corners.bottomRight.y);
      context.lineTo(corners.bottomLeft.x, corners.bottomLeft.y);
      context.closePath();
      context.stroke();
    }

    function drawCalibrationOverlay() {
      if (!calibrationData || !calibrationData.corners) return;

      const {topLeft, topRight, bottomRight, bottomLeft} = calibrationData.corners;

      // Vérification que tous les points nécessaires sont présents
      if (!topLeft || !topRight || !bottomRight || !bottomLeft) return;

      context.fillStyle = "rgba(138, 148, 255, 0.2)";
      context.beginPath();
      context.moveTo(topLeft.x, topLeft.y);
      context.lineTo(topRight.x, topRight.y);
      context.lineTo(bottomRight.x, bottomRight.y);
      context.lineTo(bottomLeft.x, bottomLeft.y);
      context.closePath();
      context.fill();
    }

    function drawId(markers) {
      if (!markers.length) return;

      context.lineWidth = 2;
      context.font = "bold 30px Arial";
      context.textAlign = "center";

      markers.forEach(marker => {
        const corners = marker.corners;

        // Calculer le centre une seule fois
        const center = corners.reduce(
                (acc, corner) => ({
                  x: acc.x + corner.x / corners.length,
                  y: acc.y + corner.y / corners.length
                }),
                { x: 0, y: 0 }
        );

        const rotation = calculateRotation(corners);

        // Regrouper les opérations de dessin pour réduire les changements de contexte
        context.save();

        // Point central
        context.beginPath();
        context.arc(center.x, center.y, 12, 0, 2 * Math.PI);
        context.fillStyle = 'lightblue';
        context.fill();

        // ID
        context.fillStyle = "white";
        context.fillText(`ID: ${marker.id}`, center.x, center.y - 20);

        // Lignes de rotation
        context.beginPath();
        // Ligne de référence
        context.strokeStyle = "lightblue";
        context.lineWidth = 4;
        context.moveTo(center.x, center.y);
        context.lineTo(center.x + 120, center.y);
        context.stroke();

        // Ligne de rotation
        const lineLength = 180;
        const endX = center.x + lineLength * Math.cos((rotation * Math.PI) / 180);
        const endY = center.y + lineLength * Math.sin((rotation * Math.PI) / 180);

        context.beginPath();
        context.strokeStyle = "lime";
        context.lineWidth = 6;
        context.moveTo(center.x, center.y);
        context.lineTo(endX, endY);
        context.stroke();

        // Arc d'angle
        context.beginPath();
        context.strokeStyle = "pink";
        context.lineWidth = 4;
        context.arc(center.x, center.y, 70, 0, (rotation * Math.PI) / 180);
        context.stroke();

        // Texte d'angle
        const textX = center.x + 80 * Math.cos((rotation * Math.PI) / 360);
        const textY = center.y + 80 * Math.sin((rotation * Math.PI) / 360);
        context.fillStyle = "pink";
        context.fillText(`${Math.round(rotation)}°`, textX, textY);

        context.restore();

        // Envoyer les données une fois les calculs terminés
        sendMarkerData(marker.id, center.x, center.y, rotation);
      });
    }

    window.onload = onLoad;
  </script>
</head>

<body>
<div class="container">
  <header class="header">
  <div class="controls">
      <button id="toggleButton" class="button" onclick="toggleFilter()">
        Enable Filter
      </button>
      <button id="calibrationButton" class="button" onclick="startCalibration()">
        Calibrate
      </button>
      <button id="saveCalibrationButton" class="button"
              onclick="saveCalibration()"
              style="display:none">
        Save Calibration
      </button>
    </div>
  </header>

  <main>
    <video id="video" autoplay="true"></video>
    <canvas id="canvas"></canvas>
  </main>
</div>
</body>
</html>